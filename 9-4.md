# 9.4 Relationship Between Superclasses and Subclasses

We now use an inheritance hierarchy containing types of employees in a company’s payroll
application to discuss the relationship between a superclass and its subclass.
 
- 重點討論 : 
  - inheritence
  - superclass
  - subclass

In this company, commission employees (who will be represented as objects of a superclass) are paid a
percentage of their sales, while base-salaried commission employees (who will be represented
as objects of a subclass) receive a base salary plus a percentage of their sales.



We divide our discussion of the relationship between these classes into five examples.



The first declares class `CommissionEmployee`, which directly inherits from class `Object`
and declares as `private` instance variables a first name, last name, social security number,
commission rate and gross (i.e., total) sales amount.

- CommissionEmployee
  - inherits Object
  - private variables


The second example declares class `BasePlusCommissionEmployee`, which also directly
inherits from class `Object` and declares as `private` instance variables a first name, last
name, social security number, commission rate, gross sales amount and base salary. 

- `BasePlusCommissionEmployee`
  - inherits Object
  - private variables


We create this class by writing every line of code the class requires—we’ll soon see that it’s much
more efficient to create it by inheriting from class `CommissionEmployee`.



The third example declares a new `BasePlusCommissionEmployee` class that extends
class `CommissionEmployee` (i.e., a `BasePlusCommissionEmployee` is a `CommissionEmployee` who also has a base salary). 

- `BasePlusCommissionEmployee`
  - extends `CommissionEmployee`



This software **reuse** lets us write much less code when developing the new subclass. 




In this example, class `BasePlusCommissionEmployee`
attempts to access class `CommissionEmployee’s` `private` members—this results in compilation errors, because the subclass cannot access the superclass’s private instance variables.

- **subclass CANNOT access superclass's private instance variables**


The fourth example shows that if `CommissionEmployee’s` instance variables are
declared as `protected`, the `BasePlusCommissionEmployee` subclass can access that data
directly. 

- if `CommissionEmployee’s` variables are `protected`
- subclass(`BasePlusCommissionEmployee`) **CAN** access


Both `BasePlusCommissionEmployee` classes contain identical functionality, but
we show how the inherited version is easier to create and manage.


After we discuss the convenience of using `protected` instance variables, we create the
fifth example, which sets the `CommissionEmployee` instance variables back to `private` to
enforce good software engineering. 

- `CommissionEmployee` variables are turned into `private`


Then we show how the `BasePlusCommissionEmployee` subclass can use `CommissionEmployee’s` `public` methods to manipulate (in a controlled manner) the `private` instance variables inherited from `CommissionEmployee`.

- subclass(`BasePlusCommissionEmployee`)
  - can use `CommissionEmployee’s` `public`
  - to access `private` instance variables
  - inherited from `CommissionEmployee`



## 9.4.1 Creating and Using a CommissionEmployee Class

We begin by declaring class `CommissionEmployee` (Fig. 9.4). 



Line 4 begins the class declaration and indicates that class `CommissionEmployee` extends (i.e., `inherits` from) class `Object` (from package java.lang). 

```java
public class CommissionEmployee extends Object
```


This causes class `CommissionEmployee` to inherit the class
Object’s methods — class Object does not have any fields. 

- `CommissionEmployee` inherits methods
  - bc Object have no fields


If you don’t explicitly specify
which class a new class extends, the class extends `Object` implicitly. 

- `Object` will be extend implicitly

For this reason, you typically will not include “extends Object” in your code—we do so in this one example only for demonstration purposes.


### Overview of Class CommissionEmployee’s Methods and Instance Variables
Class `CommissionEmployee’s` `public` services include a constructor (lines 13–34) and
methods `earnings` (lines 87–90) and `toString` (lines 93–101). 

```java
// five-argument constructor
public CommissionEmployee(String firstName, String lastName, String socialSecurityNumber, double grossSales, double commissionRate) {
    // implicit call to Object's default constructor occurs here
    // if grossSales is invalid throw exception
    if (grossSales < 0.0)
        throw new IllegalArgumentException("Gross sales must be >= 0.0");
    // if commissionRate is invalid throw exception
    if (commissionRate <= 0.0 || commissionRate >= 1.0)
        throw new IllegalArgumentException("Commission rate must be > 0.0 and &lt; 1.0");
    this.firstName = firstName;
    this.lastName = lastName;
    this.socialSecurityNumber = socialSecurityNumber;
    this.grossSales = grossSales;
    this.commissionRate = commissionRate;
} // end constructor
```
```java
    public double earnings() {
        return commissionRate * grossSales;
    }
```

```java
    // return String representation of CommissionEmployee object
    @Override // indicates that this method overrides a superclass method
    public String toString() {
        return String.format("%s: %s %s%n%s: %s%n%s: %.2f%n%s: %.2f",
                "commission employee", firstName, lastName,
                "social security number", socialSecurityNumber, // end class CommissionEmployee
                "gross sales", grossSales,
                "commission rate", commissionRate);

    }
```


Lines 37–52 declare `public` get methods for the class’s `final` instance variables (declared in lines 6–8) `firstName`, `lastName` and `socialSecurityNumber`. 

```java
    // return first name
    public String getFirstName() {
        return firstName;
    }

    // return last name
    public String getLastName() {
        return lastName;
    }

    // return social security number
    public String getSocialSecurityNumber() {
        return socialSecurityNumber;
    }
```

These three instance variables are declared `final` because they do not need to be modified after they’re initialized—this is also why we do not provide corresponding set methods. 

- 沒有 set method 是因為已經定義成 `final` 了

Lines 55–84 declare `public` set and get methods for the class’s `grossSales` and `commissionRate` instance variables (declared in lines 9–10).

```java
    // set gross sales amount
    public void setGrossSales(double grossSales) {
        if (grossSales < 0.0)
            throw new IllegalArgumentException(
                    "Gross sales must be >= 0.0");
        this.grossSales = grossSales;
    }

    // return gross sales amount
    public double getGrossSales() {
        return grossSales;
    }

    // set commission rate
    public void setCommissionRate(double commissionRate) {
        if (commissionRate <= 0.0 || commissionRate >= 1.0)
            throw new IllegalArgumentException(
                    "Commission rate must be > 0.0 and < 1.0");
        this.commissionRate = commissionRate;
    }

    // return commission rate
    public double getCommissionRate() {
        return commissionRate;
    }
```


The class declares its instance variables as `private`, so objects of other classes cannot directly access these variables.


### Class CommissionEmployee’s Constructor
Constructors are not inherited, so class `CommissionEmployee` does not inherit class Object’s constructor. 

- constructors 不會被 inherited

However, a superclass’s constructors are still available to be called by
subclasses. 

- 但是 superclass 的 constructors 可以被 subclass call


In fact, Java requires that the first task of any subclass constructor is to call its direct
superclass’s constructor, either explicitly or implicitly (if no constructor call is specified), to
ensure that the instance variables inherited from the superclass are initialized properly.


- java 說一定要 call superclass's constructor
- ensure that the instance variable 繼承 from the superclass
- 可以 initialized properly

The syntax for calling a `superclass` constructor explicitly is discussed in Section 9.4.3. 



In this
example, class `CommissionEmployee’s` constructor calls class `Object’s` constructor implicitly. 

- CommissionEmployee’s constructor call Object's constructor implicitly



If the code does not include an explicit call to the `superclass` constructor, Java implicitly calls the superclass’s default or no-argument constructor. 

- 不管怎麼樣, java 會 implicitly call superclass's default or no-argument constructor


The comment in line 17 of Fig. 9.4 indicates where the implicit call to the superclass Object’s default constructor is made (you do not write the code for this call). 

- 不需要 write code
- 就會自動 call superclass's default constructor


Object’s default constructor does nothing.

- Object's default constructor 不會做任何事

Even if a class does not have constructors, the default constructor that the compiler implicitly declares for the class will call the superclass’s default or no-argument constructor.

- 即便一個 class 沒有 constructors
- the default constructor 還是會 call superclass's default or no-argument constructor


After the implicit call to Object’s constructor, lines 20–22 and 25–27 validate the
`grossSales` and `commissionRate` arguments. 



If these are valid (that is, the constructor does not throw an IllegalArgumentException), lines 29–33 assign the constructor’s arguments to the class’s instance variables.




We did not validate the values of arguments `firstName`, `lastName` and `socialSecurityNumber` before assigning them to the corresponding instance variables. 



We could validate the first and last names—perhaps to ensure that they’re of a reasonable length.


Similarly, a social security number could be validated using regular expressions
(Section 14.7) to ensure that it contains nine digits, with or without dashes (e.g., 123-45-
6789 or 123456789).



### Class CommissionEmployee’s earnings Method
Method `earnings` (lines 87–90) calculates a `CommissionEmployee’s` earnings. 
Line 89 multiplies the `commissionRate` by the `grossSales` and returns the result.


```java
   // calculate earnings
    public double earnings() {
        return commissionRate * grossSales;
    }
```

### Class CommissionEmployee’s toString Method and the @Override Annotation
Method `toString` (lines 93–101) is special—it’s one of the methods that every class inherits directly or indirectly from class `Object` (summarized in Section 9.6). 

- `toString` : 每一個 class inherits directly or indirectly from `Object` 

Method `toString` returns a String representing an object. 

- `toString` returns a `String`
- 用 String 表示 Object

It’s called implicitly whenever an object must be
converted to a String representation, such as when an object is output by printf or output by String method format via the `%s` format specifier. 




Class Object’s `toString` method returns a `String` that includes the name of the object’s class.


 
It’s primarily a placeholder that can be overridden by a subclass to specify an appropriate `String` representation of the data in a subclass object. 



Method `toString` of class `CommissionEmployee` overrides (redefines) class Object’s `toString` method. 

- 在 `CommissionEmployee` 的 toString 會 override `Object`'s `toString`



When invoked, `CommissionEmployee’s` `toString` method uses `String` method format to return a String containing information about the `CommissionEmployee`. 

- `CommissionEmployee’s` `toString` 被觸發的時候, 會使用 `String` 的 method `format` 
- return a String 



To override a superclass method, a subclass must declare a method
with the same signature (method name, number of parameters, parameter types and order
of parameter types) as the superclass method — Object’s `toString` method takes no parameters, so `CommissionEmployee` declares toString with no parameters.

- override a superclass method
- declare same method name, number of parameters, parameter types and order
of parameter types






Line 93 uses the optional `@Override` annotation to indicate that the following
method declaration (i.e., `toString`) should override an existing superclass method. 

```java
    @Override // indicates that this method overrides a superclass method
```


This annotation helps the compiler catch a few common errors. 


For example, in this case, you intend to override superclass method `toString`, which is spelled with a lowercase “t” and an uppercase “S.” 


If you inadvertently use a lowercase “s,” the compiler will flag this as an
error because the superclass does not contain a method named `toString`. 

- 如果不小心用了 s
- the compiler 會有 error
- 因為 superclass 沒有包含 method tostring


If you didn’t use the `@Override` annotation, `toString` would be an entirely different method that would not be called if a `CommissionEmployee` were used where a String was needed.

- 如果沒有使用 `@Override`
- `toString` 就會變成完全不一樣的 method


Another common overriding error is declaring the wrong number or types of parameters in the parameter list. 

- 常見的 error
- declare the wrong number or types of parameters

This creates an unintentional overload of the superclass method,
rather than overriding the existing method. 

- 這一個會變 overload method


If you then attempt to call the method (with the correct number and types of parameters) on a subclass object, the superclass’s version is invoked—potentially leading to subtle logic errors. 

- 如果企圖去 call the method(有相同的 number and types of parameters)
- 在 a subclass object
- 那麼 superclass 的 method 會被 call
- 會導致 logic error


When the compiler encounters a method declared with `@Override`, it compares the method’s signature with the superclass’s method signatures. 

- 當 the compiler encounters 遇到 `@Override`
- 會跟 superclass's method 比較

If there isn’t an exact match, the compiler issues an error message, such
as “method does not override or implement a method from a supertype.” 

- 如果沒有 match
- 那麼就會丟出 error

You would then correct your method’s signature so that it matches one in the superclass

#### Error-Prevention Tip 9.1

Though the `@Override` annotation is optional, declare overridden methods with it to ensure at compilation time that you defined their signatures correctly. It’s always better to
find errors at compile time rather than at runtime. For this reason, the toString methods
in Fig. 7.9 and in Chapter 8’s examples should have been declared with @Override.

#### Common Programming Error 9.1
It’s a compilation error to override a method with a more restricted access modifier—a
`public` superclass method cannot become a `protected` or `private` subclass method; a `protected` superclass method cannot become a `private` subclass method. 

superclass | subclass
-----------|----------
public | x protected x private
protected | x private


Doing so would break the is-a relationship, which requires that all subclass objects be able to respond to method calls made to public methods declared in the superclass. 

- 這樣做會 break `is-a` 的關係

If a `public` method, could
be overridden as a `protected` or `private` method, the subclass objects would not be able
to respond to the same method calls as superclass objects. 


Once a method is declared `public`
in a superclass, the method remains `public` for all that class’s direct and indirect subclasses.


### Class CommissionEmployeeTest

Figure 9.5 tests class `CommissionEmployee`. 

Lines 9–10 instantiate a `CommissionEmployee`
object and invoke `CommissionEmployee’s` constructor (lines 13–34 of Fig. 9.4) to initialize
it with "Sue" as the first name, "Jones" as the last name, "222-22-2222" as the social security number, 10000 as the gross sales amount ($10,000) and .06 as the commission rate (i.e.,
6%). 


Lines 15–24 use `CommissionEmployee’s` get methods to retrieve the object’s instancevariable values for output. 


Lines 26–27 invoke the object’s `setGrossSales` and `setCommissionRate` methods to change the values of instance variables `grossSales` and `commissionRate`. 


Lines 29–30 output the String representation of the updated CommissionEmployee.

When an object is output using the `%s` format specifier, the object’s `toString` method is invoked implicitly to obtain the object’s `String` representation. 


### 9.4.2 Creating and Using a BasePlusCommissionEmployee Class
We now discuss the second part of our introduction to inheritance by declaring and testing
(a completely new and independent) class `BasePlusCommissionEmployee` (Fig. 9.6),
which contains a first name, last name, social security number, gross sales amount, commission rate and base salary. 


Class `BasePlusCommissionEmployee’s` public services include a `BasePlusCommissionEmployee` constructor (lines 15–42) and methods `earnings`
(lines 111–114) and `toString` (lines 117–126). 

- public services 有 3 個
  - constructor
  - `earnings()`
  - `toString()`


Lines 45–108 declare `public` get and set methods for the class’s `private` instance variables (declared in lines 7–12) `firstName`,
`lastName`, `socialSecurityNumber`, `grossSales`, `commissionRate` and `baseSalary`.

- declare `public` getter and setter 
- for `private` instance variables

These variables and methods encapsulate all the necessary features of a base-salaried commission employee. 

Note the similarity between this class and class `CommissionEmployee`
(Fig. 9.4)—in this example, we’ll not yet exploit that similarity.

Class `BasePlusCommissionEmployee` does not specify “extends Object” in line 5, so
the class implicitly extends `Object`. 

- 不管有沒有寫 java 都會 extends `Object`

Also, like class `CommissionEmployee`’s constructor
(lines 13–34 of Fig. 9.4), class `BasePlusCommissionEmployee`’s constructor invokes class
`Object`’s default constructor implicitly, as noted in the comment in line 19.

- 在執行自己的 constructor 之前
- 會 invoke Object's default constructor implicitly

Class `BasePlusCommissionEmployee`’s `earnings` method (lines 111–114) returns the
result of adding the `BasePlusCommissionEmployee`’s base salary to the product of the
commission rate and the employee’s gross sales.

```java
    // calculate earnings
    public double earnings() {
        return baseSalary + (commissionRate * grossSales);
    }
```

Class `BasePlusCommissionEmployee` overrides `Object` method `toString` to return a
`String` containing the `BasePlusCommissionEmployee`’s information. 

- override Object's `toString` method

Once again, we use format specifier `%.2f` to format the gross sales, commission rate and base salary with two digits of precision to the right of the decimal point (line 121).

```java
    // return String representation of BasePlusCommissionEmployee
    @Override
    public String toString() {
        return String.format(
                "%s: %s %s%n%s: %s%n%s: %.2f%n%s: %.2f%n%s: %.2f",
                "base-salaried commission employee"
                , firstName, lastName,
                "social security number", socialSecurityNumber,
                "gross sales", grossSales, "commission rate", commissionRate, "base salary", baseSalary);
    }
```

### Testing Class BasePlusCommissionEmployee
Figure 9.7 tests class `BasePlusCommissionEmployee`. 


Lines 9–11 create a `BasePlusCommissionEmployee` object and pass "Bob", "Lewis", "333-33-3333", 5000, .04 and 300 to the constructor as the first name, last name, social security number, gross sales, commission rate and base salary, respectively. 


Lines 16–27 use `BasePlusCommissionEmployee`’s get methods to retrieve the values of the object’s instance variables for output. 


Line 29 invokes the object’s `setBaseSalary` method to change the base salary. 


Method `setBaseSalary` (Fig. 9.6, lines 95–102) ensures that instance variable baseSalary is not assigned a negative value. 


Line 33 of Fig. 9.7 invokes method `toString` explicitly to get the object’s
String representation.


### Notes on Class BasePlusCommissionEmployee
Much of class `BasePlusCommissionEmployee`’s code (Fig. 9.6) is similar, or identical, to
that of class `CommissionEmployee` (Fig. 9.4). 



For example, `private` instance variables
`firstName` and `lastName` and methods `setFirstName`, `getFirstName`, `setLastName` and
`getLastName` are identical to those of class `CommissionEmployee`. 




The classes also both
contain `private` instance variables `socialSecurityNumber`, `commissionRate` and `grossSales`, and corresponding get and set methods. 


In addition, the `BasePlusCommissionEmployee` constructor is almost identical to that of class `CommissionEmployee`, except that
`BasePlusCommissionEmployee’s` constructor also sets the `baseSalary`. 

```java
    // six-argument constructor
    public BasePlusCommissionEmployee(String firstName, String lastName,
                                      String socialSecurityNumber, double grossSales,
                                      double commissionRate, double baseSalary) {

        // implicit call to Object's default constructor occurs here
        // if grossSales is invalid throw exception
        if (grossSales &lt; 0.0)
            throw new IllegalArgumentException(
                    "Gross sales must be >= 0.0");
        // if commissionRate is invalid throw exception
        if (commissionRate &lt;= 0.0 || commissionRate >= 1.0)
            throw new IllegalArgumentException(
                    "Commission rate must be > 0.0 and &lt; 1.0");
        // if baseSalary is invalid throw exception
        if (baseSalary &lt; 0.0)
            throw new IllegalArgumentException(
                    "Base salary must be >= 0.0");
        this.firstName = firstName;
        this.lastName = lastName;
        this.socialSecurityNumber = socialSecurityNumber;
        this.grossSales = grossSales;
        this.commissionRate = commissionRate;
        this.baseSalary = baseSalary;
    } // end constructor
```

The other additions to class `BasePlusCommissionEmployee` are `private` instance variable `baseSalary`
and methods `setBaseSalary` and `getBaseSalary`. 

- `BasePlusCommissionEmployee` 加上 `baseSalary` `setBaseSalary` `getBaseSalary`





Class `BasePlusCommissionEmployee`’s
`toString` method is almost identical to that of class `CommissionEmployee` except that it
also outputs instance variable `baseSalary` with two digits of precision to the right of the
decimal point.



We literally copied code from class `CommissionEmployee` and pasted it into class `BasePlusCommissionEmployee`, then modified class `BasePlusCommissionEmployee` to include
a base salary and methods that manipulate the base salary. 


This “copy-and-paste” approach is often error prone and time consuming. 

- copy and paste 會導致很多的錯誤
- 而且耗時間

Worse yet, it spreads copies of the same code throughout a system, creating code-maintenance problems—changes to the code would need to be made in multiple classes. 

- code 幾乎都是一樣的
- 如果 code 要改
- 會很麻煩

### Software Engineering Observation 9.3
With inheritance, the instance variables and methods that are the same for all the classes
in the hierarchy are declared in a superclass. 
Changes made to these common features in
the superclass are inherited by the subclass. 
Without inheritance, changes would need to
be made to all the source-code files that contain a copy of the code in question.


## 9.4.3 Creating a CommissionEmployee–
`BasePlusCommissionEmployee` Inheritance Hierarchy
Now we declare class `BasePlusCommissionEmployee` (Fig. 9.8) to extend class `CommissionEmployee` (Fig. 9.4). 


A `BasePlusCommissionEmployee` object is a `CommissionEmployee`, because inheritance passes on class `CommissionEmployee`’s capabilities. 

- `BasePlusCommissionEmployee` object is a `CommissionEmployee`



Class `BasePlusCommissionEmployee` also has instance variable `baseSalary` (Fig. 9.8, line 6).



Keyword `extends` (line 4) indicates **inheritance**. 

- `extends` == inheritence


`BasePlusCommissionEmployee` inherits `CommissionEmployee`’s instance variables and methods.

- `BasePlusCommissionEmployee` 會繼承 `CommissionEmployee` 的 instance variable and methods

### Software Engineering Observation 9.4
At the design stage in an object-oriented system, you’ll often find that certain classes are
closely related. 

You should “factor out” common instance variables and methods and place
them in a superclass. 

- 如果很多東西都很像, 就可以放到 superclass 裡面

Then use inheritance to develop subclasses, specializing them with
capabilities beyond those inherited from the superclass.

- 然後使用 inheritence to develop subclasses
- and specialize subclasses

### Software Engineering Observation 9.5
Declaring a subclass does not affect its superclass’s source code. 

- declare a subclass 不會影響 superclass's source code

Inheritance preserves the integrity of the superclass.

- inheritance 會保留 superclass 的完整性

Only `CommissionEmployee`’s `public` and `protected` members are directly accessible
in the subclass. 

- parent class's 的 `public` and `protected` members
- are accessible in the subclass

parent | child
-------|--------
private | x
public | O
protected | O


The `CommissionEmployee` constructor is not inherited. 

- **subclass 是不會繼承 parent class's 的 constructor**

So, the public
`BasePlusCommissionEmployee` services include its constructor (lines 9–23), public
methods inherited from `CommissionEmployee`, and methods `setBaseSalary` (lines 26–
33), `getBaseSalary` (lines 36–39), `earnings` (lines 42–47) and `toString` (lines 50–60).

- 所以 subclass 會繼承 parent's public method

```java
    // six-argument constructor
    public BasePlusCommissionEmployee(String firstName, String lastName,
                                      String socialSecurityNumber, double grossSales,
                                      double commissionRate, double baseSalary) {

// explicit call to superclass CommissionEmployee constructor
        super(firstName, lastName, socialSecurityNumber,
                grossSales, commissionRate);
        // if baseSalary is invalid throw exception
        if (baseSalary &lt; 0.0)
            throw new IllegalArgumentException(
                    "Base salary must be >= 0.0");
        this.baseSalary = baseSalary;
    }
```

Methods `earnings` and `toString` override the corresponding methods in class `CommissionEmployee` because their superclass versions do not properly calculate a `BasePlusCommissionEmployee’s` earnings or return an appropriate String representation, respectively.

```java
    @Override

    // calculate earnings
    public double earnings() {
        // not allowed: commissionRate and grossSales private in superclass
        return baseSalary + (commissionRate * grossSales);
    }

    // return String representation of BasePlusCommissionEmployee
    @Override
    public String toString() {

// not allowed: attempts to access private superclass members
        return String.format(
                "%s: %s %s%n%s: %s%n%s: %.2f%n%s: %.2f%n%s: %.2f",
                "base-salaried commission employee", firstName, lastName,
                "social security number", socialSecurityNumber,
                "gross sales", grossSales, "commission rate", commissionRate,
                "base salary", baseSalary);
    }
```

### A Subclass’s Constructor Must Call Its Superclass’s Constructor
Each subclass constructor must implicitly or explicitly call one of its superclass’s constructors to initialize the instance variables inherited from the superclass. 


- 每一個 subclass constructor 都一定要 call superclass's constructor
- to initialize the instance variable
- instance variables are inherited from the superclass

Lines 14–15 in `BasePlusCommissionEmployee`’s six-argument constructor (lines 9–23) explicitly call class `CommissionEmployee`’s five-argument constructor (declared at lines 13–34 of Fig. 9.4) to
initialize the superclass portion of a `BasePlusCommissionEmployee` object (i.e., variables
firstName, lastName, socialSecurityNumber, grossSales and commissionRate). 

- subclass call parent class's constructor 


We
do this by using the superclass constructor call syntax—keyword `super`, followed by a set
of parentheses containing the superclass constructor arguments, which are used to initialize the superclass instance variables `firstName`, `lastName`, `socialSecurityNumber`,
`grossSales` and `commissionRate`, respectively. 

- 使用 superclass constructor 
- keyword `super`
- 後面有 superclass 的 constructor arguments


If `BasePlusCommissionEmployee`’s constructor did not invoke the superclass’s constructor explicitly, the compiler would attempt
to insert a call to the superclass’s default or no-argument constructor. 

- if subclass's constructor did not invoke superclass's constructor explicitly
- the compiler would insert a call 
- to the superclass's default or no-argument constructor


Class `CommissionEmployee` does not have such a constructor, so the compiler would issue an error. 

- superclass here doesn't have such a constructor
- the program will have an error

The explicit superclass constructor call in lines 14–15 of Fig. 9.8 must be the first statement in
the constructor’s body. 

- 必須要第一個 call superclass's constructor


When a superclass contains a no-argument constructor, you can
use `super()` to call that constructor explicitly, but this is rarely done.

- a superclass contains a no-argument constructor
- use `super()`
- rarely done


#### Software Engineering Observation 9.6
You learned previously that you should not call a class’s instance methods from its
constructors and that we’ll say why in Chapter 10. Calling a superclass constructor from
a subclass constructor does not contradict this advice.

- should not call a class's instance methods
- from constructors
- calling a superclass constructor from a subclass constructor 
- doesn't contradict




### BasePlusCommissionEmployee Methods Earnings and toString
The compiler generates errors for line 46 (Fig. 9.8) because `CommissionEmployee`’s instance variables `commissionRate` and `grossSales` are private—subclass `BasePlusCommissionEmployee`’s methods are not allowed to access superclass `CommissionEmployee`’s
`private` instance variables. 

- subclass methods are not allowed to access superclass's private instance variable


We used red text in Fig. 9.8 to indicate erroneous code. 



The
compiler issues additional errors at lines 56–58 of `BasePlusCommissionEmployee`’s `toString` method for the same reason. 



The errors in `BasePlusCommissionEmployee` could
have been prevented by using the get methods inherited from class `CommissionEmployee`.



For example, line 46 could have called `getCommissionRate` and `getGrossSales` to access
``CommissionEmployee``’s `private` instance variables ``commissionRate`` and `grossSales`, respectively. 

- if subclass wanna access superclass's private variables
- you need to use the get method

Lines 56–58 also could have used appropriate get methods to retrieve the values
of the superclass’s instance variables.


## 9.4.4 CommissionEmployee–BasePlusCommissionEmployee Inheritance Hierarchy Using protected Instance Variables
To enable class `BasePlusCommissionEmployee` to directly access superclass instance variables `firstName`, `lastName`, `socialSecurityNumber`, `grossSales` and `commissionRate`,
we can declare those members as `protected` in the superclass. 

- if subclass wanna access superclass instance variables
- we can declare superclass's instance variables to protected



As we discussed in
Section 9.3, a superclass’s `protected` members are accessible by all subclasses of that superclass. 

- subclasses can access superclass's protected instance variables


In the new `CommissionEmployee` class, we modified only lines 6–10 of Fig. 9.4
to declare the instance variables with the `protected` access modifier as follows:

```java
protected final String firstName;
protected final String lastName;
protected final String socialSecurityNumber;
protected double grossSales; // gross weekly sales
protected double commissionRate; // commission percentage
```


The rest of the class declaration (which is not shown here) is identical to that of Fig. 9.4.


We could have declared `CommissionEmployee`’s instance variables `public` to enable subclass `BasePlusCommissionEmployee` to access them. 


However, declaring public instance
variables is poor software engineering because it allows unrestricted access to the these variables from any class, greatly increasing the chance of errors. 

- declare public instance variables
- is not a great choice
- bc it allows unrestricted access
- to variables from any class

With `protected` instance variables, the subclass gets access to the instance variables, but classes that are not subclasses and
classes that are not in the same package cannot access these variables directly—recall that
`protected` class members are also visible to other classes in the same package.


- protected instance variables are visible to other classes in the same package
- but it can only be accessed by its' subclasses

### Class BasePlusCommissionEmployee
Class `BasePlusCommissionEmployee` (Fig. 9.9) extends the new version of class `CommissionEmployee` with `protected` instance variables. `BasePlusCommissionEmployee` objects
inherit `CommissionEmployee`’s `protected` instance variables `firstName`, `lastName`, `socialSecurityNumber`, `grossSales` and `commissionRate` —all these variables are now `protected` members of `BasePlusCommissionEmployee`. As a result, the compiler does not
generate errors when compiling line 45 of method earnings and lines 54–56 of method
`toString`. If another class extends this version of class `BasePlusCommissionEmployee`, the
new subclass also can access the `protected` members.

### A Subclass Object Contains the Instance Variables of All of Its Superclasses
When you create a `BasePlusCommissionEmployee` object, it contains all instance variables
declared in the class hierarchy to that point—that is, those from classes `Object` (which
does not have instance variables), `CommissionEmployee` and `BasePlusCommissionEmployee`. 


- create a subclass object
- this object contains `Object`, `CommissionEmployee`, `BasePlusCommissionEmployee` instance variables





Class `BasePlusCommissionEmployee` does not inherit `CommissionEmployee`’s five-argument constructor, but explicitly invokes it (lines 14–15) to initialize the instance variables
that `BasePlusCommissionEmployee` inherited from `CommissionEmployee`. 


- subclasses do not inherit parentclass's constructor
- we need to explicitly invoke it
- to initialize the instance variables
- that subclasses inherit from


Similarly, `CommissionEmployee`’s constructor implicitly calls class `Object`’s constructor. 

- subclass (`CommissionEmployee`) constructor implicitly call superclass's(`Object`) constructor


`BasePlusCommissionEmployee`’s constructor must explicitly call `CommissionEmployee`’s constructor
because `CommissionEmployee` does not have a no-argument constructor that could be invoked implicitly.


- `BasePlusCommissionEmployee` 一定要寫出來是因為 superclass `CommissionEmployee` 的 constructor 並沒有 default constructor 可以 invoke


### Testing Class BasePlusCommissionEmployee
The `BasePlusCommissionEmployeeTest` class for this example is identical to that of
Fig. 9.7 and produces the same output, so we do not show it here. 

Although the version of
class `BasePlusCommissionEmployee` in Fig. 9.6 does not use inheritance and the version in
Fig. 9.9 does, both classes provide the same functionality. 

The source code in Fig. 9.9 (59
lines) is considerably shorter than that in Fig. 9.6 (127 lines), because most of the class’s
functionality is now inherited from `CommissionEmployee`—there’s now only one copy of
the `CommissionEmployee` functionality. This makes the code easier to maintain, modify
and debug, because the code related to a `CommissionEmployee` exists only in that class.



### Notes on Using protected Instance Variables
In this example, we declared superclass instance variables as `protected` so that subclasses
could access them. 

Inheriting `protected` instance variables enables direct access to the
variables by subclasses. In most cases, however, it’s better to use `private` instance variables
to encourage proper software engineering. 

Your code will be easier to maintain, modify
and debug.


Using protected instance variables creates several potential problems. 


First, the subclass object can set an inherited variable’s value directly without using a set method. 

- subclass object can set a value without using a set method

Therefore, a subclass object can assign an invalid value to the variable, possibly leaving the object
in an inconsistent state. 

- subclass object can assign an invalid value

For example, if we were to declare `CommissionEmployee`’s instance
variable `grossSales` as protected, a subclass object (e.g., `BasePlusCommissionEmployee`)
could then assign a negative value to `grossSales`. 

- we can assign a sales number to a negative number


Another problem with using `protected`
instance variables is that subclass methods are more likely to be written so that they depend
on the superclass’s data implementation. 

- subclass methods are more likely to be written
- so they depand on superclass's data implementation

In practice, subclasses should depend only on the
superclass services (i.e., `non-private` methods) and not on the superclass data implementation. 

- subclasses should depand on public or protected methods
- not on the superclass data implementation


With `protected` instance variables in the superclass, we may need to modify all the
subclasses of the superclass if the superclass implementation changes. 

- 有 protected instance variables
- modify all the subclasses 
- if the superclass implementation changes

For example, if for
some reason we were to change the names of instance variables `firstName` and `lastName`
to first and last, then we would have to do so for all occurrences in which a subclass
directly references superclass instance variables `firstName` and `lastName`. 

- 假如現在要改 superclass 的 firstName 和 lastName 變成 first 和 last
- 但是這 2 個是 protected
- 所以如果 subclasses 有用到這 2 個 variables
- 也要跟著改成 first 和 last

Such a class is
said to be fragile or brittle, because a small change in the superclass can “break” subclass
implementation. 


You should be able to change the superclass implementation while still
providing the same services to the subclasses. 


Of course, if the superclass services change,
we must reimplement our subclasses. 


A third problem is that a class’s `protected` members are visible to all classes in the same package as the class containing the `protected` members—this is not always desirable.

- protected members are visiable to all classes in the same packages


### Software Engineering Observation 9.7
Use the `protected` access modifier when a superclass should provide a method only to its
subclasses and other classes in the same package, but not to other clients.

- protected 只適合用來 provide a method


### Software Engineering Observation 9.8
Declaring superclass instance variables `private` (as opposed to `protected`) enables the
superclass implementation of these instance variables to change without affecting subclass
implementations.

- declare instance variables `privates`


### Error-Prevention Tip 9.2
When possible, do not include `protected` instance variables in a superclass. 
Instead, include non-private methods that access private instance variables. This will help ensure
that objects of the class maintain consistent states.


## 9.4.5 CommissionEmployee–BasePlusCommissionEmployee Inheritance Hierarchy Using private Instance Variables

Let’s reexamine our hierarchy once more, this time using good software engineering practices.

### Class CommissionEmployee
Class `CommissionEmployee` (Fig. 9.10) declares instance variables `firstName`, `lastName`,
`socialSecurityNumber`, `grossSales` and `commissionRate` as `private` (lines 6–10) and
provides `public` methods `getFirstName`, `getLastName`, `getSocialSecurityNumber`, `setGrossSales`, `getGrossSales`, `setCommissionRate`, `getCommissionRate`, `earnings` and
`toString` for manipulating these values. 



Methods `earnings` (lines 87–90) and `toString`
(lines 93–101) use the class’s get methods to obtain the values of its instance variables. 


If
we decide to change the names of the instance variables, the earnings and toString declarations will not require modification—only the bodies of the get and set methods that directly manipulate the instance variables will need to change. 

- if we need to change the names of the instance variables
- we only need to change the getters and setters

These changes occur solely
within the superclass—no changes to the subclass are needed. 

- 只會在 superclass 裡面發生
- subclass 全部都不用動


Localizing the effects of changes like this is a good software engineering practice.

### Class BasePlusCommissionEmployee
Subclass `BasePlusCommissionEmployee` (Fig. 9.11) inherits `CommissionEmployee’s` nonprivate methods and can access (in a controlled way) the `private` superclass members via
those methods. 

- subclasses 繼承 superclass 的 public, protected methods
- 可以 access the private superclass members

Class `BasePlusCommissionEmployee` has several changes that distinguish
it from Fig. 9.9. 



Methods `earnings` (lines 43–47) and `toString` (lines 50–55) each invoke
method `getBaseSalary` to obtain the base salary value, rather than accessing `baseSalary`
directly. If we decide to rename instance variable baseSalary, only the bodies of method
`setBaseSalary` and `getBaseSalary` will need to change.


- 除了 getters and setters 可以直接接觸 private variables
- 其他的 method 都必須要用 getter and setter 來去拿 private variables


### Class BasePlusCommissionEmployee’s earnings Method
Method `earnings` (lines 43–47) overrides class `CommissionEmployee`’s `earnings` method
(Fig. 9.10, lines 87–90) to calculate a base-salaried commission employee’s `earnings`. The
new version obtains the portion of the earnings based on commission alone by calling CommissionEmployee’s earnings method with `super.earnings()` (line 46), then adds the
base salary to this value to calculate the total earnings. 

```java
    @Override

    // calculate earnings
    public double earnings() {
        // not allowed: commissionRate and grossSales private in superclass
        return  getBaseSalary() + super.earnings();
    }
```

- 因為 superclass 已經有 earnings 這一個 method
- 所以可以 override method
- 如果像要用的話
- 就必須要用 `super.methodName()`



Note the syntax used to invoke an
overridden superclass method from a subclass—place the keyword super and a dot (.) separator before the superclass method name. 


This method invocation is a good software engineering practice—if a method performs all or some of the actions needed by another
method, call that method rather than duplicate its code. 


By having BasePlusCommissionEmployee’s earnings method invoke CommissionEmployee’s earnings method to calculate part of a BasePlusCommissionEmployee object’s earnings, we avoid duplicating the
code and reduce code-maintenance problems.


### Common Programming Error 9.2
When a superclass method is overridden in a subclass, the subclass version often calls the
superclass version to do a portion of the work. 


Failure to prefix the superclass method name
with the keyword super and the dot (.) separator when calling the superclass’s method
causes the subclass method to call itself, potentially creating an error called infinite recursion, which would eventually cause the method-call stack to overflow—a fatal runtime
error. Recursion, used correctly, is a powerful capability discussed in Chapter 18.

- 沒有用 super 這一個 keyword
- 表示會有 recursion 發生
- 那麼自己呼叫自己沒有中止條件的話
- 會導致 stack overflow


### Class BasePlusCommissionEmployee’s toString Method
Similarly, `BasePlusCommissionEmployee`’s `toString` method (Fig. 9.11, lines 50–55)
overrides `CommissionEmployee`’s `toString` method (Fig. 9.10, lines 93–101) to return a
String representation that’s appropriate for a base-salaried commission employee. 



The new
version creates part of a `BasePlusCommissionEmployee` object’s String representation (i.e.,
the String "commission employee" and the values of class CommissionEmployee’s private
instance variables) by calling `CommissionEmployee`’s toString method with the expression
`super.toString()` (Fig. 9.11, line 54). 


`BasePlusCommissionEmployee`’s `toString` method then completes the remainder of a `BasePlusCommissionEmployee` object’s String representation (i.e., the value of class `BasePlusCommissionEmployee`’s base salary).


### Testing Class BasePlusCommissionEmployee
Class `BasePlusCommissionEmployeeTest` performs the same manipulations on a `BasePlusCommissionEmployee` object as in Fig. 9.7 and produces the same output, so we do
not show it here. 


Although each `BasePlusCommissionEmployee` class you’ve seen behaves
identically, the version in Fig. 9.11 is the best engineered. 

By using inheritance and by calling methods that hide the data and ensure consistency, we’ve efficiently and effectively
constructed a well-engineered class.

